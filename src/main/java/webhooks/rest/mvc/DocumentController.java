/**
 * Copyright 2015 Workfront, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package webhooks.rest.mvc;

import org.apache.tika.io.*;
import org.springframework.beans.factory.annotation.*;
import org.springframework.http.*;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.context.*;
import org.springframework.web.multipart.*;
import webhooks.core.models.entities.*;
import webhooks.core.services.*;
import webhooks.core.services.exceptions.*;
import webhooks.core.services.util.*;
import webhooks.rest.exceptions.*;
import webhooks.rest.resources.*;
import webhooks.rest.resources.asm.*;

import javax.imageio.*;
import javax.servlet.*;
import javax.servlet.http.*;
import java.awt.image.*;
import java.io.*;
import java.net.*;
import java.util.*;

@Controller
@RequestMapping("/rest/api")
public class DocumentController implements ServletContextAware {
	private static final int defaultMaxCount = 100;
	private IDocumentService documentService;
	private ServletContext context;

	@Autowired
	private AccountController accountController;

	@Autowired
	public DocumentController(IDocumentService documentService) {
		this.documentService = documentService;
	}

	@Override
	public void setServletContext(ServletContext servletContext) {
		this.context = servletContext;
	}


	/**
	 * Find a document from persistent store (linked document)
	 * @param id Document id.  Not required.  If missing will try to get all documents from database
	 * @return Metadata in response
	 */
	@RequestMapping(value = "/documents",
					method = RequestMethod.GET)
	public ResponseEntity<DocumentResponse[]> findAllDocuments(@RequestParam(value="id", required = false) String id){
			DocumentList list;

		if (!accountController.authenticate()) {
			return new ResponseEntity<DocumentResponse[]>(new DocumentListResource().toDocumentResponseArray(), HttpStatus.FORBIDDEN);
		}
			if(id == null) {
			list = documentService.findAllDocuments();
		} else {
			Document document = documentService.getDocumentByID(id);
			if(document == null) {
				list = new DocumentList(new ArrayList<Document>());
			} else {
				list = new DocumentList(Arrays.asList(document));
			}
		}
		DocumentListResource res = new DocumentListResourceAsm().toResource(list);
		return new ResponseEntity<DocumentResponse[]>(res.toDocumentResponseArray(), HttpStatus.OK);
	}

	/**
	 * Get document metadata based on document id.
	 * @param documentId Unique document identification generated by the app. Required for the api.
	 * @return document metadata in response.
	 */
	@RequestMapping(value = "/metadata",
					method = RequestMethod.GET)
	public ResponseEntity<DocumentResponse> getMetadata(@RequestParam(value = "id", required = true) String documentId){
		if (!accountController.authenticate()) {
			return new ResponseEntity<DocumentResponse>(new DocumentResponse(), HttpStatus.FORBIDDEN);
		}
			Document document = documentService.getMetaData(documentId);
		if (document != null) {
			DocumentResource res = new DocumentResourceAsm().toResource(document);
			return new ResponseEntity<DocumentResponse>(res.toDocumentResponse(), HttpStatus.OK);
		} else {
			return new ResponseEntity<DocumentResponse>(new DocumentResponse(), HttpStatus.NOT_FOUND);
		}
	}

	/**
	 *  Get a list of files and folders.
	 * @param parentID The folder ID to which documents should be gotten from.  It's not required parameter.  If no data provided, root folder will be used.
	 * @param max Maximum number of returned items.  Not required.  If not provided, defaultMaxCount (100) will be used.
	 * @param offset Starting offset of documents to retrieve. Not required.  Default to 0 as starting offset.
	 * @return An array of document metadata
	 */
	@RequestMapping(value = "/files",
					method = RequestMethod.GET)
	public ResponseEntity<DocumentResponse[]> getFiles(@RequestParam(value = "parentId", required = false) String parentID,
													   @RequestParam(value = "max", required = false) Integer max,
													   @RequestParam(value = "offset", required = false) Integer offset){

		if (!accountController.authenticate()) {
			//return new ResponseEntity<DocumentResponse[]>(HttpStatus.FORBIDDEN);
			return new ResponseEntity<DocumentResponse[]>(new DocumentListResource().toDocumentResponseArray(), HttpStatus.FORBIDDEN);
		}

		int maxInt = (max == null) ? defaultMaxCount : max.intValue();
		int offsetInt = (offset == null || offset.intValue() < 0) ? 0 : offset.intValue();
		DocumentList list = (parentID == null) ? documentService.getRootFiles(maxInt, offsetInt) : documentService.getFiles(parentID, maxInt,offsetInt);
		DocumentListResource res = new DocumentListResourceAsm().toResource(list);
		return new ResponseEntity<DocumentResponse[]>(res.toDocumentResponseArray(), HttpStatus.OK);
	}


	/**
	 *  Initialize a file upload and expect a response metadata with document id provided.
	 * @param parentID Parent container id (directory/folder).  Not required.  Default to root container.
	 * @param fileName The name of the document to be uploaded.  It is a required parameter.
	 * @return Document metadata in response with new document id provided.
	 */
	@RequestMapping(value = "uploadInit",
					method = RequestMethod.POST)
	public ResponseEntity<DocumentResponse> uploadStart(@RequestParam(value = "parentId", required = false) String parentID,
													   @RequestParam(value = "filename", required = true) String fileName) {
		try {
			if (!accountController.authenticate()) {
				return new ResponseEntity<DocumentResponse>(new DocumentResponse(), HttpStatus.FORBIDDEN);
			}
				Document document = documentService.uploadStart(parentID, fileName);
			if (document != null) {
				DocumentResource res = new DocumentResourceAsm().toResource(document);
				return new ResponseEntity<DocumentResponse>(res.toDocumentResponse(), HttpStatus.OK);
			} else {
				return new ResponseEntity<DocumentResponse>(HttpStatus.INTERNAL_SERVER_ERROR);
			}
		}catch (DocumentExistsException e) {
				return new ResponseEntity<DocumentResponse>(new DocumentResponse(), HttpStatus.CONFLICT);
		}
	}

	/**
	 * Upload a document with an id generated through the uploadInit call.
	 * @param documentID Document id.  This is a required parameter which can be gotten through uploadInit call.
	 * @param request HttpServletRequest of the call
	 * @return Upload response in json success/fail for ex. {result:"success", message:"xxxxxx"}
	 */
	@RequestMapping(value = "upload",
					method = RequestMethod.PUT,
					headers = "content-type!=multipart/form-data")
	public ResponseEntity<UploadResponse> upload(@RequestParam(value = "id", required = true) String documentID,
												   final HttpServletRequest request){
		if (!accountController.authenticate()) {
			return new ResponseEntity<UploadResponse>(new UploadResponse(), HttpStatus.FORBIDDEN);
		}

		UploadResponse response = new UploadResponse();
		try {
			InputStream inputStream = request.getInputStream();

			if (documentService.uploadEnd(documentID, inputStream)) {
				response.setResult(UploadResponse.SUCCESS);
				return new ResponseEntity<UploadResponse>(response, HttpStatus.OK);
			} else {
				response.setResult(UploadResponse.FAILED);
				response.setMessage("Upload Failed");

				return new ResponseEntity<UploadResponse>(response, HttpStatus.OK);
		}

		} catch (IOException e) {
				response.setResult(UploadResponse.FAILED);
				response.setMessage("Upload Failed");
				return new ResponseEntity<UploadResponse>(response, HttpStatus.OK);
		}
	}

	@RequestMapping(value = "upload",
					method = RequestMethod.PUT,
					headers = "content-type=multiple/form-data")
	public ResponseEntity<UploadResponse> upload(@RequestParam(value = "id", required = true) String documentID,
												   final MultipartHttpServletRequest request){

		if (!accountController.authenticate()) {
			return new ResponseEntity<UploadResponse>(new UploadResponse(), HttpStatus.FORBIDDEN);
		}

		UploadResponse response = new UploadResponse();
		try {
			if (documentService.uploadEnd(documentID, request.getInputStream())) {
				response.setResult(UploadResponse.SUCCESS);
				return new ResponseEntity<UploadResponse>(response, HttpStatus.OK);
			} else {
				response.setResult(UploadResponse.FAILED);
				response.setMessage("Upload Failed");

				return new ResponseEntity<UploadResponse>(response, HttpStatus.OK);
			}
		} catch (IOException e) {
				response.setResult(UploadResponse.FAILED);
				response.setMessage("Upload Failed");
				return new ResponseEntity<UploadResponse>(response, HttpStatus.OK);
		}
	}


	/**
	 * Query the provider for expected returned.  The current implementation actually returns a list of files that satisfy the query pattern (regular expression).
	 * Empty list will be returned if no query specified.
	 * @param query Pattern for querying the system. (regular expression supported). Not required.
	 * @param max Maximum allowable number of returned documents. Not required.  DefaultMaxCount (100) will be used if missing.
	 * @param offset Starting offset of documents to retrieve. Not required.  Default to 0 as starting offset.
	 * @return
	 */
	@RequestMapping(value = "/search",
					method = RequestMethod.GET)
	public ResponseEntity<DocumentResponse[]> findFiles(@RequestParam(value = "query", required = false) String query,
														@RequestParam(value = "max", required = false) Integer max,
														@RequestParam(value = "offset", required = false) Integer offset){
		if (!accountController.authenticate()) {
			return new ResponseEntity<DocumentResponse[]>(new DocumentListResource().toDocumentResponseArray(), HttpStatus.FORBIDDEN);
		}

		DocumentList list;
		if (query != null){
			list = documentService.findFiles (query, (max == null || max.intValue() < 0) ? defaultMaxCount : max.intValue(), (offset == null) ? 0 : offset.intValue());
		} else {
			list = new DocumentList();
		}

		DocumentListResource res = new DocumentListResourceAsm().toResource(list);
		return new ResponseEntity<DocumentResponse[]>(res.toDocumentResponseArray(), HttpStatus.OK);
	}


	/**
	 * Get raw thumbnails bytes for a specific document
	 * @param documentId Document id.  Required.
	 * @param size The pixel width of the thumbnail.  Not required.  Default size (200) will be used if not provided.
	 * @return raw thumbnails bytes in response.
	 */
	@RequestMapping(value="/thumbnail",
					method = RequestMethod.GET)
	public ResponseEntity<byte[]> getThumbnail(@RequestParam(value = "id", required = true) String documentId,
											   @RequestParam(value = "size", required = false) Integer size){
		if (!accountController.authenticate()) {
			return new ResponseEntity<byte[]>(new byte[0], HttpStatus.FORBIDDEN);
		}

		Document document = documentService.getDocumentByID(documentId);
		if (document == null) {
			return new ResponseEntity<byte[]>(HttpStatus.NOT_FOUND);
		} else {
			String path = DocumentUtil.getLocationFromDocId(document.getId());

			File targetFile = new File(path);
			if (targetFile.exists()) {
				final HttpHeaders headers = new HttpHeaders();
				try {
					int defaultSize = (size == null) ? 200 : size.intValue();
					BufferedImage thumbnail = ThumbnailUtil.createThumbnail(context, path, document, defaultSize, defaultSize);
					headers.setContentType(new MediaType("image", "jpeg"));
					ByteArrayOutputStream os = new ByteArrayOutputStream();
					ImageIO.write(thumbnail, "jpeg", os);
					headers.setContentLength(os.size());
					InputStream is = new ByteArrayInputStream(os.toByteArray());
					return new ResponseEntity<byte[]>(IOUtils.toByteArray(is), headers, HttpStatus.CREATED);
				} catch (Exception e) {
					return new ResponseEntity<byte[]>(HttpStatus.NOT_FOUND);
				}
			}
			return new ResponseEntity<byte[]>(HttpStatus.NOT_FOUND);
		}
	}


	/**
	 * View a document
	 * @param documentId The id for the document to be displayed.  Required.
	 * @return Raw bytes of the display image
	 */
	@RequestMapping(value = "/view",
					method = RequestMethod.GET)
	public ResponseEntity<byte[]>viewDocument(@RequestParam(value = "id", required = true) String documentId){
		return doRetrieve(documentId, false);
	}

	/**
	 * Download a document
	 * @param documentId The id for the document to be downloaded.  Required.
	 * @return Raw bytes of the download image
	 */
	@RequestMapping(value = "/download",
					method = RequestMethod.GET)
	public ResponseEntity<byte[]> getDocument(@RequestParam(value = "id", required = true) String documentId){
		return doRetrieve(documentId, true);
	}

	private ResponseEntity<byte[]> doRetrieve(String documentId, boolean isDownload){

		if (!accountController.authenticate()) {
			return new ResponseEntity<byte[]>(new byte[0], HttpStatus.FORBIDDEN);
		}

		Document document = documentService.getDocumentByID(documentId);
		if (document == null) {
			return new ResponseEntity<byte[]>(HttpStatus.NOT_FOUND);
		} else {
			String path = DocumentUtil.getLocationFromDocId(document.getId());

			File downloadFile = new File(path);
			if (downloadFile.exists()) {
				final HttpHeaders headers = new HttpHeaders();
				if (document.getSize() > 0)
					headers.setContentLength(document.getSize());
				try {
					// always get back null in OS X
					//String contentType = Files.probeContentType(Paths.get(path));
					String mimeTypeStr = document.getMimeType();
					int idx = mimeTypeStr.lastIndexOf("/");
					String mimeType = mimeTypeStr.substring(0, idx);
					String mimeSubType = mimeTypeStr.substring(idx + 1, mimeTypeStr.length());

					headers.setContentType(new MediaType(mimeType, mimeSubType));
					if (isDownload) {
						headers.set(HttpHeaders.CONTENT_DISPOSITION, "attachment");
					} else {
						headers.set(HttpHeaders.CONTENT_DISPOSITION, "inline");
					}

					InputStream is = new FileInputStream(path);
					return new ResponseEntity<byte[]>(IOUtils.toByteArray(is), headers, HttpStatus.CREATED);
				} catch (IOException e) {
					return new ResponseEntity<byte[]>(new byte[0], HttpStatus.INTERNAL_SERVER_ERROR);
				}
			}
			return new ResponseEntity<byte[]>(new byte[0], HttpStatus.NOT_FOUND);
		}
	}


	/**
	 * Add a document into persistent store
	 * @param sentDocument the document to be added in json format.
	 * @return The metadata in response
	 */
	@RequestMapping(value="link", method = RequestMethod.POST)
	public ResponseEntity<DocumentResource> addDocument(
		@RequestBody DocumentResource sentDocument) {
		if (!accountController.authenticate()) {
			return new ResponseEntity<DocumentResource>(new DocumentResource(), HttpStatus.FORBIDDEN);
		}

		try {
			Document addDocument = documentService.addDocument(sentDocument.toDocument());
			DocumentResource res = new DocumentResourceAsm().toResource(addDocument);
			HttpHeaders headers = new HttpHeaders();
			headers.setLocation(URI.create(res.getLink("self").getHref()));
			return new ResponseEntity<DocumentResource>(res, headers, HttpStatus.CREATED);
		} catch (DocumentExistsException exception) {
			return new ResponseEntity<DocumentResource>(new DocumentResource(), HttpStatus.CONFLICT);
		}
	}
}
